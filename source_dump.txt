# ==================================================
# Path: E:\Dai Hoc\NCKH\Demo
# Detected tech: python
# ==================================================

## DIRECTORY STRUCTURE
```
Demo/
‚îú‚îÄ‚îÄ __pycache__/
‚îú‚îÄ‚îÄ blockchains/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ destination_chain.py
‚îÇ   ‚îî‚îÄ‚îÄ source_chain.py
‚îú‚îÄ‚îÄ relay_chain/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ consensus.py
‚îÇ   ‚îú‚îÄ‚îÄ relay_chain.py
‚îÇ   ‚îî‚îÄ‚îÄ validator.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ rc_to_dc.py
‚îú‚îÄ‚îÄ sc_to_rc.py
‚îú‚îÄ‚îÄ source_dump.txt
‚îî‚îÄ‚îÄ zk_simulator.py
```

## FILE CONTENTS

### main.py
```py
from blockchains.source_chain import SourceChain
from blockchains.destination_chain import DestinationChain
from relay_chain.relay_chain import RelayChain
from relay_chain.validator import ValidatorNode
from sc_to_rc import SCtoRCProver
from rc_to_dc import RCtoDCProver

# Kh·ªüi t·∫°o c√°c chu·ªói v√† validator
sc = SourceChain("chainA")
dc = DestinationChain("chainB")
validators = [ValidatorNode(f"v{i}") for i in range(4)]
rc = RelayChain(validators)

# Prover gi·ªØa SC v√† RC
sc_to_rc = SCtoRCProver(sc, rc)

# G·ª≠i giao d·ªãch t·ª´ SC ‚Üí RC
tx_id = "tx_001"
result = sc_to_rc.send_transaction({"message": "Send 100 MAP"}, tx_id)

if result["accepted"]:
    # Prover gi·ªØa RC v√† DC
    rc.generate_block()
    rc_to_dc = RCtoDCProver(rc, dc)
    rc_to_dc.send_to_destination( {"message": "Send 100 MAP"}, result["tx_hash"], tx_id)

# ƒê√≥ng block ·ªü DestinationChain
dc.generate_block()

# In k·∫øt qu·∫£
print("\nüîó SourceChain block:", sc.get_latest_block())
print("üîÅ RelayChain block:", rc.get_latest_block())
print("‚úÖ DestinationChain block:", dc.get_latest_block())

```

### rc_to_dc.py
```py
from zk_simulator import generate_zk_proof

class RCtoDCProver:
    def __init__(self, relay_chain, destination_chain):
        self.rc = relay_chain
        self.dc = destination_chain

    def send_to_destination(self, tx, tx_hash: str, tx_id: str):
        """
        1. L·∫•y block m·ªõi nh·∫•t tr√™n RC
        2. L·∫•y Merkle root v√† Merkle proof c·ªßa tx_hash
        3. T·∫°o zk proof t·ª´ tx_id + merkle_root
        4. G·ª≠i sang DestinationChain
        """
        print("\nüì§ [Prover] Sending proof from RC to DC")
        merkle_root_rc = self.rc.get_merkle_root()

        # Find index of tx_hash (do_hash=True -> hash match)
        index = None
        for i, tx in enumerate(self.rc.get_latest_block()["transactions"]):
            from zk_simulator import hash_data
            if hash_data(tx) == tx_hash:
                index = i
                break

        if index is None:
            print("‚ùå Kh√¥ng t√¨m th·∫•y tx_hash trong RC")
            return False

        # Prover
        proof_merkle = self.rc.mt.get_proof(index)
        tx_hash_id = hash_data(tx_id)
        proof_zk = generate_zk_proof(tx_id, merkle_root_rc)

        success = self.dc.receive_ctx(tx, tx_hash_id, tx_hash, merkle_root_rc, proof_merkle, proof_zk)
        print("‚úÖ DestinationChain accepted TX:" if success else "‚ùå DestinationChain rejected TX")
        return success
```

### sc_to_rc.py
```py
import json
from zk_simulator import hash_data, generate_zk_proof

class SCtoRCProver:
    def __init__(self, source_chain, relay_chain):
        self.sc = source_chain
        self.rc = relay_chain

    def send_transaction(self, tx_payload: dict, tx_id: str):
        """
        1. Th√™m giao d·ªãch v√†o SC
        2. T·∫°o block
        3. L·∫•y Merkle proof
        4. G·ª≠i l√™n RelayChain
        """
        print("\nüì§ [Prover] Sending transaction from SC to RC")
        tx = self.sc.add_transaction(tx_payload)
        block = self.sc.generate_block()
        merkle_root = block["merkle_root"]
        proof = self.sc.get_merkle_proof(tx)
        
        #Prover
        tx_hash = hash_data(tx_id)
        tx_hash_for_mkl = hash_data(tx)
        zk_proof = generate_zk_proof(tx_id, merkle_root)

        accepted = self.rc.receive_tx(tx, tx_hash, tx_hash_for_mkl, proof, merkle_root, zk_proof)
        print("‚úÖ RelayChain accepted TX:" if accepted else "‚ùå RelayChain rejected TX")
        return {
            "tx": tx,
            "tx_hash": tx_hash_for_mkl,
            "proof": proof,
            "merkle_root": merkle_root,
            "zk_proof": zk_proof,
            "accepted": accepted
        }

```

### zk_simulator.py
```py
import hashlib

def hash_data(data: str) -> str:
    return hashlib.sha256(data.encode()).hexdigest()

def generate_zk_proof(tx_id: str, merkle_root: str) -> str:
    """
    Prover t·∫°o zk proof t·ª´ d·ªØ li·ªáu b√≠ m·∫≠t (tx_id) v√† public (merkle root)
    """
    tx_hash = hash_data(tx_id)
    return hash_data(tx_hash + merkle_root)

def verify_zk_proof(proof: str, tx_hash: str, merkle_root: str) -> bool:
    """
    Verifier kh√¥ng bi·∫øt tx_id, ch·ªâ bi·∫øt hash(tx_id), v√† merkle_root.
    """
    expected = hash_data(tx_hash + merkle_root)
    return proof == expected

```

### blockchains\destination_chain.py
```py
from blockchains.source_chain import SourceChain
from zk_simulator import verify_zk_proof
from merkletools import MerkleTools

class DestinationChain(SourceChain):
    def __init__(self, chain_id):
        super().__init__(chain_id)
        self.mt = MerkleTools(hash_type="sha256")

    def receive_ctx(self, tx, tx_hash_id: str, tx_hash: str, merkle_root_rc: str, proof_merkle: list, proof_zk: str) -> bool:
        """
        Nh·∫≠n giao d·ªãch ƒë√£ relay t·ª´ RC, x√°c minh:
        1. tx_hash n·∫±m trong Merkle tree c·ªßa RC (proof_merkle)
        2. proof_zk h·ª£p l·ªá v·ªõi (tx_hash, merkle_root_rc)
        N·∫øu c·∫£ 2 ƒë√∫ng, th√™m v√†o pending_tx ƒë·ªÉ ghi block.
        """
        self.mt.reset_tree()

        # B∆∞·ªõc 1: x√°c minh Merkle proof
        is_merkle_valid = self.mt.validate_proof(proof_merkle, tx_hash, merkle_root_rc)
        
        if not is_merkle_valid:
            print("‚ùå Merkle proof invalid")
            return False

        # B∆∞·ªõc 2: x√°c minh zk gi·∫£ l·∫≠p
        is_zk_valid = verify_zk_proof(proof_zk, tx_hash_id, merkle_root_rc)

        if not is_zk_valid:
            print("‚ùå zk proof invalid")
            return False

        self.pending_tx.append(tx)
        return True

```

### blockchains\source_chain.py
```py
import hashlib
import json
from typing import List, Dict
from merkletools import MerkleTools

class SourceChain:
    def __init__(self, chain_id: str):
        self.chain_id = chain_id
        self.chain: List[Dict] = []
        self.pending_tx: List[str] = []
        self.block_height = 0
        self.mt = MerkleTools(hash_type="sha256")

    def add_transaction(self, payload: Dict) -> str:
        tx = {
            "chain_id": self.chain_id,
            "payload": payload
        }
        tx_str = json.dumps(tx, sort_keys=True)
        self.pending_tx.append(tx_str)
        return tx_str

    def _calculate_merkle_root(self, txs: List[str]) -> str:
        self.mt.reset_tree()
        for tx in txs:
            self.mt.add_leaf(tx, do_hash=True)
        self.mt.make_tree()
        return self.mt.get_merkle_root()

    def generate_block(self):
        if not self.pending_tx:
            return None

        root = self._calculate_merkle_root(self.pending_tx)
        block = {
            "height": self.block_height,
            "merkle_root": root,
            "transactions": self.pending_tx.copy()
        }
        self.chain.append(block)
        self.block_height += 1
        self.pending_tx.clear()
        return block

    def get_latest_block(self):
        return self.chain[-1] if self.chain else None

    def get_merkle_proof(self, tx: str):
        block = self.get_latest_block()
        if not block:
            return None

        self.mt.reset_tree()
        for t in block["transactions"]:
            self.mt.add_leaf(t, do_hash=True)
        self.mt.make_tree()

        try:
            index = block["transactions"].index(tx)
        except ValueError:
            return None

        return self.mt.get_proof(index)

    def get_merkle_root(self):
        block = self.get_latest_block()
        return block["merkle_root"] if block else None

    def get_block_header(self):
        block = self.get_latest_block()
        if block:
            return {
                "height": block["height"],
                "merkle_root": block["merkle_root"]
            }
        return None
```

### relay_chain\consensus.py
```py
from typing import List
from relay_chain.validator import ValidatorNode

class ConsensusEngine:
    def __init__(self, validators: List[ValidatorNode]):
        self.validators = validators
        self.quorum = (2 * len(validators)) // 3 + 1  # BFT: > 2/3 ƒë·ªìng thu·∫≠n

    def commit_tx(self, tx: str, proof: list, merkle_root: str) -> bool:
        """
        L·∫•y phi·∫øu t·ª´ t·∫•t c·∫£ validator. N·∫øu s·ªë validator ƒë·ªìng √Ω >= quorum, 
        th√¨ giao d·ªãch ƒë∆∞·ª£c ch·∫•p nh·∫≠n.
        """
        votes = 0
        for validator in self.validators:
            if validator.vote(tx, proof, merkle_root):
                votes += 1
        print(f"‚úÖ BFT votes: {votes}/{len(self.validators)}")
        return votes >= self.quorum

```

### relay_chain\relay_chain.py
```py
import json
from typing import List, Dict
from merkletools import MerkleTools
import hashlib
from relay_chain.validator import ValidatorNode
from relay_chain.consensus import ConsensusEngine
from zk_simulator import verify_zk_proof

class RelayChain:
    def __init__(self, validators: List[ValidatorNode]):
        self.chain: List[Dict] = []
        self.pending_tx: List[Dict] = []
        self.block_height = 0
        self.mt = MerkleTools(hash_type="sha256")
        self.consensus = ConsensusEngine(validators)

    def receive_tx(self, tx: str, tx_hash: str, tx_hash_formkl: str, proof: List[Dict], merkle_root: str, zk_proof: str) -> bool:
        # Step 1: verify Merkle proof
        is_valid_proof = self.mt.validate_proof(proof, tx_hash_formkl, merkle_root)
        if not is_valid_proof:
            print("‚ùå Merkle proof invalid")
            return False

        # Step 2: verify zk proof
        is_valid_zk = verify_zk_proof(zk_proof, tx_hash, merkle_root)
        if not is_valid_zk:
            print("‚ùå zk proof invalid")
            return False

        # Step 3: BFT Consensus
        approved = self.consensus.commit_tx(tx_hash_formkl, proof, merkle_root)
        if approved:
            self.pending_tx.append(tx)
            return True
        print("‚ùå BFT Consensus invalid")
        return False

    def generate_block(self):
        if not self.pending_tx:
            return None

        self.mt.reset_tree()
        for tx in self.pending_tx:
            self.mt.add_leaf(tx, do_hash=True)
        self.mt.make_tree()

        block = {
            "height": self.block_height,
            "merkle_root": self.mt.get_merkle_root(),
            "transactions": self.pending_tx.copy()
        }
        self.chain.append(block)
        self.block_height += 1
        self.pending_tx.clear()
        return block

    def get_latest_block(self):
        return self.chain[-1] if self.chain else None

    def get_merkle_root(self):
        block = self.get_latest_block()
        return block["merkle_root"] if block else None
```

### relay_chain\validator.py
```py
from merkletools import MerkleTools

class ValidatorNode:
    def __init__(self, node_id: str, is_honest: bool = True):
        self.node_id = node_id
        self.is_honest = is_honest
        self.mt = MerkleTools(hash_type="sha256")

    def vote(self, tx_hash: str, proof: list, merkle_root: str) -> bool:
        """
        Honest validator s·∫Ω t·ª± x√°c minh Merkle proof:
        - N·∫øu h·ª£p l·ªá th√¨ b·ªè phi·∫øu 'ƒë·ªìng √Ω'
        - N·∫øu kh√¥ng ho·∫∑c validator gian l·∫≠n th√¨ t·ª´ ch·ªëi
        """
        if not self.is_honest:
            return False

        # D√πng MerkleTools ƒë·ªÉ ki·ªÉm tra proof
        is_valid = self.mt.validate_proof(proof, tx_hash, merkle_root)
        return is_valid

```
