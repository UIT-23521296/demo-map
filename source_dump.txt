# ==================================================
# Path: E:\Dai Hoc\NCKH\demo-map
# Detected tech: python
# ==================================================

## DIRECTORY STRUCTURE
```
demo-map/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ __pycache__/
‚îú‚îÄ‚îÄ blockchains/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ destination_chain.py
‚îÇ   ‚îî‚îÄ‚îÄ source_chain.py
‚îú‚îÄ‚îÄ lightclient/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ light_client_rc.py
‚îÇ   ‚îî‚îÄ‚îÄ light_client_sc.py
‚îú‚îÄ‚îÄ prover/
‚îÇ   ‚îú‚îÄ‚îÄ prover_rc_to_dc.py
‚îÇ   ‚îî‚îÄ‚îÄ prover_sc_to_rc.py
‚îú‚îÄ‚îÄ relay_chain/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ consensus.py
‚îÇ   ‚îú‚îÄ‚îÄ relay_chain.py
‚îÇ   ‚îî‚îÄ‚îÄ validator.py
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ dc_server.py
‚îÇ   ‚îú‚îÄ‚îÄ rc_server.py
‚îÇ   ‚îî‚îÄ‚îÄ sc_server.py
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ client_demo.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ rc_to_dc.py
‚îú‚îÄ‚îÄ sc_to_rc.py
‚îú‚îÄ‚îÄ source_dump.txt
‚îî‚îÄ‚îÄ zk_simulator.py
```

## FILE CONTENTS

### client_demo.py
```py
import requests, json, time
from zk_simulator import hash_data

tx_id   = "tx_001"
payload = {"msg": "Send 100 MAP"}
reiceiver = "chainB"

# 1. SC
r = requests.post("http://localhost:5001/send_tx",
                  json={"tx_id": tx_id, "receiver": reiceiver, "payload": payload}).json()
tx  = r["tx"]; print("SC block:", r["block"]["height"])
block = r["block"]

# 2. L·∫•y proof
pr = requests.post("http://localhost:5004/get_proof", json={"tx":tx, "merkle_root": block["merkle_root"]}).json()

# 3. H·ªèi prover SC‚ÜíRC ƒë·ªÉ l·∫•y zk_proof, tx_hash
# pv = requests.post("http://localhost:5004/prove",
#                    json={"tx_id":tx_id, "merkle_root":pr["merkle_root"]}).json()

# 3. Push l√™n RC
rc_res = requests.post("http://localhost:5002/relay_tx", json={
    "tx"           : tx,
    "tx_hash"      : hash_data(tx_id),
    "tx_hash_mkl"  : hash_data(tx),
    "proof"        : pr["proof"],
    "merkle_root"  : pr["merkle_root"],
    "zk_proof"     : pr["zk_proof"]
}).json()
print("RC accept?", rc_res["accepted"])

# 5. RC ƒë√≥ng block
requests.get("http://localhost:5002/get_block")

pr_rc_dc = requests.post("http://localhost:5005/get_proof", json={"tx":tx, "merkle_root": block["merkle_root"]}).json()

# 6. G·ª≠i ctx sang DC
rc_res = requests.post("http://localhost:5003/receive_tx", json={
    "tx"           : tx,
    "tx_hash"      : hash_data(tx_id),
    "tx_hash_mkl"  : hash_data(tx),
    "proof"        : pr_rc_dc["proof"],
    "merkle_root"  : pr_rc_dc["merkle_root"],
    "zk_proof"     : pr_rc_dc["zk_proof"]
}).json()
print("DC accept?", rc_res["accepted"])

# 7. DC seal
blk = requests.get("http://localhost:5003/get_block").json()
print("DC block:", json.dumps(blk, indent=2))

```

### main.py
```py
from blockchains.source_chain import SourceChain
from blockchains.destination_chain import DestinationChain
from relay_chain.relay_chain import RelayChain
from relay_chain.validator import ValidatorNode
from sc_to_rc import SCtoRCProver
from rc_to_dc import RCtoDCProver

# Kh·ªüi t·∫°o c√°c chu·ªói v√† validator
sc = SourceChain("chainA")
dc = DestinationChain("chainB")
validators = [ValidatorNode(f"v{i}") for i in range(4)]
rc = RelayChain(validators)

# Prover gi·ªØa SC v√† RC
sc_to_rc = SCtoRCProver(sc, rc)

# G·ª≠i giao d·ªãch t·ª´ SC ‚Üí RC
tx_id = "tx_001"
receiver = "chainB"
result = sc_to_rc.send_transaction({"message": "Send 100 MAP"}, receiver, tx_id)

if result["accepted"]:
    # Prover gi·ªØa RC v√† DC
    rc.generate_block()
    rc_to_dc = RCtoDCProver(rc, dc)
    rc_to_dc.send_to_destination( {"message": "Send 100 MAP"}, result["tx_hash"], tx_id)

# ƒê√≥ng block ·ªü DestinationChain
dc.generate_block()

# In k·∫øt qu·∫£
print("\nüîó SourceChain block:", sc.get_latest_block())
print("üîÅ RelayChain block:", rc.get_latest_block())
print("‚úÖ DestinationChain block:", dc.get_latest_block())

```

### rc_to_dc.py
```py
from zk_simulator import generate_zk_proof

class RCtoDCProver:
    def __init__(self, relay_chain, destination_chain):
        self.rc = relay_chain
        self.dc = destination_chain

    def send_to_destination(self, tx, tx_hash: str, tx_id: str):
        """
        1. L·∫•y block m·ªõi nh·∫•t tr√™n RC
        2. L·∫•y Merkle root v√† Merkle proof c·ªßa tx_hash
        3. T·∫°o zk proof t·ª´ tx_id + merkle_root
        4. G·ª≠i sang DestinationChain
        """
        print("\nüì§ [Prover] Sending proof from RC to DC")
        merkle_root_rc = self.rc.get_merkle_root()

        # Find index of tx_hash (do_hash=True -> hash match)
        index = None
        for i, tx in enumerate(self.rc.get_latest_block()["transactions"]):
            from zk_simulator import hash_data
            if hash_data(tx) == tx_hash:
                index = i
                break

        if index is None:
            print("‚ùå Kh√¥ng t√¨m th·∫•y tx_hash trong RC")
            return False

        # Prover
        proof_merkle = self.rc.mt.get_proof(index)
        tx_hash_id = hash_data(tx_id)
        proof_zk = generate_zk_proof(tx_id, merkle_root_rc)

        success = self.dc.receive_ctx(tx, tx_hash_id, tx_hash, merkle_root_rc, proof_merkle, proof_zk)
        print("‚úÖ DestinationChain accepted TX:" if success else "‚ùå DestinationChain rejected TX")
        return success
```

### sc_to_rc.py
```py
import json
from zk_simulator import hash_data, generate_zk_proof

class SCtoRCProver:
    def __init__(self, source_chain, relay_chain):
        self.sc = source_chain
        self.rc = relay_chain

    def send_transaction(self, tx_payload: dict, tx_receiver: str, tx_id: str):
        """
        1. Th√™m giao d·ªãch v√†o SC
        2. T·∫°o block
        3. L·∫•y Merkle proof
        4. G·ª≠i l√™n RelayChain
        """
        print("\nüì§ [Prover] Sending transaction from SC to RC")
        tx = self.sc.add_transaction(tx_payload, tx_receiver, tx_id)
        block = self.sc.generate_block()
        merkle_root = block["merkle_root"]
        proof = self.sc.get_merkle_proof(tx)
        
        #Prover
        tx_hash = hash_data(tx_id)
        tx_hash_for_mkl = hash_data(tx)
        zk_proof = generate_zk_proof(tx_id, merkle_root)

        accepted = self.rc.receive_tx(tx, tx_hash, tx_hash_for_mkl, proof, merkle_root, zk_proof)
        print("‚úÖ RelayChain accepted TX:" if accepted else "‚ùå RelayChain rejected TX")
        return {
            "tx": tx,
            "tx_hash": tx_hash_for_mkl,
            "proof": proof,
            "merkle_root": merkle_root,
            "zk_proof": zk_proof,
            "accepted": accepted
        }

```

### zk_simulator.py
```py
import hashlib

def hash_data(data: str) -> str:
    return hashlib.sha256(data.encode()).hexdigest()

def generate_zk_proof(tx_id: str, merkle_root: str) -> str:
    """
    Prover t·∫°o zk proof t·ª´ d·ªØ li·ªáu b√≠ m·∫≠t (tx_id) v√† public (merkle root)
    """
    tx_hash = hash_data(tx_id)
    return hash_data(tx_hash + merkle_root)

def verify_zk_proof(proof: str, tx_hash: str, merkle_root: str) -> bool:
    """
    Verifier kh√¥ng bi·∫øt tx_id, ch·ªâ bi·∫øt hash(tx_id), v√† merkle_root.
    """
    expected = hash_data(tx_hash + merkle_root)
    return proof == expected

```

### blockchains\destination_chain.py
```py
from blockchains.source_chain import SourceChain
from zk_simulator import verify_zk_proof
from merkletools import MerkleTools

class DestinationChain(SourceChain):
    def __init__(self, chain_id):
        super().__init__(chain_id)
        self.mt = MerkleTools(hash_type="sha256")

    def receive_ctx(self, tx, tx_hash_id: str, tx_hash: str, merkle_root_rc: str, proof_merkle: list, proof_zk: str) -> bool:
        """
        Nh·∫≠n giao d·ªãch ƒë√£ relay t·ª´ RC, x√°c minh:
        1. tx_hash n·∫±m trong Merkle tree c·ªßa RC (proof_merkle)
        2. proof_zk h·ª£p l·ªá v·ªõi (tx_hash, merkle_root_rc)
        N·∫øu c·∫£ 2 ƒë√∫ng, th√™m v√†o pending_tx ƒë·ªÉ ghi block.
        """
        self.mt.reset_tree()

        # B∆∞·ªõc 1: x√°c minh Merkle proof
        is_merkle_valid = self.mt.validate_proof(proof_merkle, tx_hash, merkle_root_rc)
        
        if not is_merkle_valid:
            print("‚ùå Merkle proof invalid")
            return False

        # B∆∞·ªõc 2: x√°c minh zk gi·∫£ l·∫≠p
        is_zk_valid = verify_zk_proof(proof_zk, tx_hash_id, merkle_root_rc)

        if not is_zk_valid:
            print("‚ùå zk proof invalid")
            return False

        self.pending_tx.append(tx)
        return True

```

### blockchains\source_chain.py
```py
import hashlib
import json
from typing import List, Dict
from merkletools import MerkleTools

class SourceChain:
    def __init__(self, chain_id: str):
        self.chain_id = chain_id
        self.chain: List[Dict] = []
        self.pending_tx: List[str] = []
        self.block_height = 0
        self.mt = MerkleTools(hash_type="sha256")

    def add_transaction(self, payload: Dict, tx_receiver: str, tx_id: str) -> str:
        tx = {
            "tx_id": tx_id,
            "chain_id": self.chain_id,
            "receiver": tx_receiver,
            "payload": payload
        }
        tx_str = json.dumps(tx, sort_keys=True)
        self.pending_tx.append(tx_str)
        return tx_str

    def _calculate_merkle_root(self, txs: List[str]) -> str:
        self.mt.reset_tree()
        for tx in txs:
            self.mt.add_leaf(tx, do_hash=True)
        self.mt.make_tree()
        return self.mt.get_merkle_root()

    def generate_block(self):
        if not self.pending_tx:
            return None

        root = self._calculate_merkle_root(self.pending_tx)
        block = {
            "height": self.block_height,
            "merkle_root": root,
            "transactions": self.pending_tx.copy()
        }
        self.chain.append(block)
        self.block_height += 1
        self.pending_tx.clear()
        return block

    def get_latest_block(self):
        return self.chain[-1] if self.chain else None

    def get_merkle_proof(self, tx: str):
        block = self.get_latest_block()
        if not block:
            return None

        self.mt.reset_tree()
        for t in block["transactions"]:
            self.mt.add_leaf(t, do_hash=True)
        self.mt.make_tree()

        try:
            index = block["transactions"].index(tx)
        except ValueError:
            return None

        return self.mt.get_proof(index)

    def get_merkle_root(self):
        block = self.get_latest_block()
        return block["merkle_root"] if block else None

    def get_block_header(self):
        block = self.get_latest_block()
        if block:
            return {
                "height": block["height"],
                "merkle_root": block["merkle_root"]
            }
        return None
```

### lightclient\light_client_rc.py
```py
# light_client_sc.py  (ch·∫°y b√™n trong RC)
from merkletools import MerkleTools
import json
from zk_simulator import verify_zk_proof, hash_data

class LightClientRC:
    """
    Light-client ƒë·ªìng b·ªô & x√°c minh block SC (chainA) ·ªü ph√≠a RC.
    """
    def __init__(self):
        self.finalized_header = None          # l∆∞u header m·ªõi nh·∫•t
        self.merkle_root      = None          # r_mkl c·ªßa header
        # tu·ª≥ thi·∫øt k·∫ø b·∫°n th√™m validator_set, epoch, v.v.

    # ---------- phase ‚Äúsync header‚Äù ----------
    def update_header(self, header: dict):
        """
        header = {height, merkle_root, ...}   (gi·∫£ l·∫≠p header t·ªëi gi·∫£n)
        """
        # ·ªü b·∫£n ƒë·∫ßy ƒë·ªß b·∫°n s·∫Ω verify ch·ªØ k√Ω + BFT threshold tr∆∞·ªõc khi ch·∫•p nh·∫≠n
        if (self.finalized_header is None) or (header["height"] > self.finalized_header["height"]):
            self.finalized_header = header
            self.merkle_root      = header["merkle_root"]
            return True
        return False

    # ---------- phase ‚Äúverify proof‚Äù ----------
    def verify_tx(self, ctx: str, merkle_proof: list, zk_proof: str) -> bool:
        """
        ctx  : chu·ªói tx (ƒë√£ JSON.dumps)
        merkle_proof : proof k√®m theo
        zk_proof     : proof gi·∫£ l·∫≠p
        """
        if self.finalized_header is None:
            return False                      # ch∆∞a sync header

        mt = MerkleTools(hash_type="sha256")
        tx_hash_mkl = hash_data(ctx)

        mkl_ok = mt.validate_proof(
            merkle_proof,
            tx_hash_mkl,
            self.merkle_root
        )

        # tx_id n·∫±m trong payload ‚áí l√¥i ra ƒë·ªÉ t·∫°o tx_hash_id
        tx_id        = json.loads(ctx)["tx_id"]
        tx_hash_id   = hash_data(tx_id)
        zk_ok        = verify_zk_proof(zk_proof, tx_hash_id, self.merkle_root)

        return mkl_ok and zk_ok

```

### lightclient\light_client_sc.py
```py
# light_client_sc.py  (ch·∫°y b√™n trong RC)
from merkletools import MerkleTools
import json
from zk_simulator import verify_zk_proof, hash_data

class LightClientSC:
    """
    Light-client ƒë·ªìng b·ªô & x√°c minh block SC (chainA) ·ªü ph√≠a RC.
    """
    def __init__(self):
        self.finalized_header = None          # l∆∞u header m·ªõi nh·∫•t
        self.merkle_root      = None          # r_mkl c·ªßa header
        # tu·ª≥ thi·∫øt k·∫ø b·∫°n th√™m validator_set, epoch, v.v.

    # ---------- phase ‚Äúsync header‚Äù ----------
    def update_header(self, header: dict):
        """
        header = {height, merkle_root, ...}   (gi·∫£ l·∫≠p header t·ªëi gi·∫£n)
        """
        # ·ªü b·∫£n ƒë·∫ßy ƒë·ªß b·∫°n s·∫Ω verify ch·ªØ k√Ω + BFT threshold tr∆∞·ªõc khi ch·∫•p nh·∫≠n
        if (self.finalized_header is None) or (header["height"] > self.finalized_header["height"]):
            self.finalized_header = header
            self.merkle_root      = header["merkle_root"]
            return True
        return False

    # ---------- phase ‚Äúverify proof‚Äù ----------
    def verify_tx(self, ctx: str, merkle_proof: list, zk_proof: str) -> bool:
        """
        ctx  : chu·ªói tx (ƒë√£ JSON.dumps)
        merkle_proof : proof k√®m theo
        zk_proof     : proof gi·∫£ l·∫≠p
        """
        if self.finalized_header is None:
            return False                      # ch∆∞a sync header

        mt = MerkleTools(hash_type="sha256")
        tx_hash_mkl = hash_data(ctx)

        mkl_ok = mt.validate_proof(
            merkle_proof,
            tx_hash_mkl,
            self.merkle_root
        )

        # tx_id n·∫±m trong payload ‚áí l√¥i ra ƒë·ªÉ t·∫°o tx_hash_id
        tx_id        = json.loads(ctx)["tx_id"]
        tx_hash_id   = hash_data(tx_id)
        zk_ok        = verify_zk_proof(zk_proof, tx_hash_id, self.merkle_root)

        return mkl_ok and zk_ok

```

### prover\prover_rc_to_dc.py
```py
# prover_rc_dc.py
import sys, os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify
import requests
import json
from zk_simulator import generate_zk_proof, hash_data

app = Flask(__name__)

RC_URL = "http://localhost:5002"

# ---- API: l·∫•y Merkle-proof th√¥ng qua SC-server -------
@app.route("/get_proof", methods=["POST"])
def get_proof():
    tx          = request.json["tx"]           # string transaction
    # G·ªçi SC-server ƒë·ªÉ l·∫•y proof + root
    resp = requests.post(f"{RC_URL}/get_proof", json={"tx": tx}, timeout=2)
    sc_data = resp.json()                      # {"proof": [...], "merkle_root": "...."}

    # K√®m th√™m zk_proof (tu·ª≥ b·∫°n c√≥ c·∫ßn hay kh√¥ng)
    tx_dict = json.loads(tx)         # ‚úÖ chuy·ªÉn string ‚Üí dict
    tx_id   = tx_dict["tx_id"]       # ‚úÖ l·∫•y tx_id t·ª´ dict
    zk_proof    = generate_zk_proof(tx_id, sc_data["merkle_root"])

    return jsonify({
        "proof"      : sc_data["proof"],
        "merkle_root": sc_data["merkle_root"],
        "zk_proof"   : zk_proof,
        "tx"         : tx
    })

if __name__ == "__main__":
    app.run(port=5005)

```

### prover\prover_sc_to_rc.py
```py
# prover_sc_rc.py
import sys, os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify
import json
import requests
from zk_simulator import generate_zk_proof, hash_data

app = Flask(__name__)


SC_URL = "http://localhost:5001" # ƒë·ªãa ch·ªâ Source-Chain server


# ---- API: sinh zk proof ------
@app.route("/prove", methods=["POST"])
def prove():
    tx_id = request.json["tx_id"]
    merkle_root = request.json["merkle_root"]
    zk_proof = generate_zk_proof(tx_id, merkle_root)
    tx_hash = hash_data(tx_id)
    return jsonify({
        "zk_proof": zk_proof,
        "tx_hash": tx_hash
    })


# ---- API: l·∫•y Merkle-proof th√¥ng qua SC-server -------
@app.route("/get_proof", methods=["POST"])
def get_proof():
    tx          = request.json["tx"]           # string transaction
    # G·ªçi SC-server ƒë·ªÉ l·∫•y proof + root
    resp = requests.post(f"{SC_URL}/get_proof", json={"tx": tx}, timeout=2)
    sc_data = resp.json()                      # {"proof": [...], "merkle_root": "...."}

    # K√®m th√™m zk_proof (tu·ª≥ b·∫°n c√≥ c·∫ßn hay kh√¥ng)
    tx_dict = json.loads(tx)         # ‚úÖ chuy·ªÉn string ‚Üí dict
    tx_id   = tx_dict["tx_id"]       # ‚úÖ l·∫•y tx_id t·ª´ dict
    zk_proof    = generate_zk_proof(tx_id, sc_data["merkle_root"])

    return jsonify({
        "proof"      : sc_data["proof"],
        "merkle_root": sc_data["merkle_root"],
        "zk_proof"   : zk_proof,
        "tx"         : tx
    })

if __name__ == "__main__":
    app.run(port=5004)

```

### relay_chain\consensus.py
```py
from typing import List
from relay_chain.validator import ValidatorNode

class ConsensusEngine:
    def __init__(self, validators: List[ValidatorNode]):
        self.validators = validators
        self.quorum = (2 * len(validators)) // 3 + 1  # BFT: > 2/3 ƒë·ªìng thu·∫≠n

    def commit_tx(self, tx: str, proof: list, merkle_root: str) -> bool:
        """
        L·∫•y phi·∫øu t·ª´ t·∫•t c·∫£ validator. N·∫øu s·ªë validator ƒë·ªìng √Ω >= quorum, 
        th√¨ giao d·ªãch ƒë∆∞·ª£c ch·∫•p nh·∫≠n.
        """
        votes = 0
        for validator in self.validators:
            if validator.vote(tx, proof, merkle_root):
                votes += 1
        print(f"‚úÖ BFT votes: {votes}/{len(self.validators)}")
        return votes >= self.quorum

```

### relay_chain\relay_chain.py
```py
import json
from typing import List, Dict
from merkletools import MerkleTools
import hashlib
from relay_chain.validator import ValidatorNode
from relay_chain.consensus import ConsensusEngine
from zk_simulator import *
from merkletools import MerkleTools

class RelayChain:
    def __init__(self, validators: List[ValidatorNode]):
        self.chain: List[Dict] = []
        self.pending_tx: List[Dict] = []
        self.block_height = 0
        self.mt = MerkleTools(hash_type="sha256")
        self.consensus = ConsensusEngine(validators)

    def receive_tx(self, tx: str, tx_hash: str, tx_hash_formkl: str, proof: List[Dict], merkle_root: str, zk_proof: str) -> bool:
        # Step 1: verify Merkle proof
        is_valid_proof = self.mt.validate_proof(proof, tx_hash_formkl, merkle_root)
        if not is_valid_proof:
            print("‚ùå Merkle proof invalid")
            return False

        # Step 2: verify zk proof
        is_valid_zk = verify_zk_proof(zk_proof, tx_hash, merkle_root)
        if not is_valid_zk:
            print("‚ùå zk proof invalid")
            return False

        # Step 3: BFT Consensus
        approved = self.consensus.commit_tx(tx_hash_formkl, proof, merkle_root)
        if approved:
            self.pending_tx.append(tx)
            return True
        print("‚ùå BFT Consensus invalid")
        return False

    def generate_block(self):
        if not self.pending_tx:
            return None

        self.mt.reset_tree()
        for tx in self.pending_tx:
            self.mt.add_leaf(tx, do_hash=True)
        self.mt.make_tree()

        block = {
            "height": self.block_height,
            "merkle_root": self.mt.get_merkle_root(),
            "transactions": self.pending_tx.copy()
        }
        self.chain.append(block)
        self.block_height += 1
        self.pending_tx.clear()
        return block

    def get_latest_block(self):
        return self.chain[-1] if self.chain else None

    def get_merkle_root(self):
        block = self.get_latest_block()
        return block["merkle_root"] if block else None
    
    def get_merkle_proof(self, tx: str):
        block = self.get_latest_block()
        if not block:
            return None

        self.mt.reset_tree()
        for t in block["transactions"]:
            self.mt.add_leaf(t, do_hash=True)
        self.mt.make_tree()

        try:
            index = block["transactions"].index(tx)
        except ValueError:
            return None

        return self.mt.get_proof(index)
```

### relay_chain\validator.py
```py
from merkletools import MerkleTools

class ValidatorNode:
    def __init__(self, node_id: str, is_honest: bool = True):
        self.node_id = node_id
        self.is_honest = is_honest
        self.mt = MerkleTools(hash_type="sha256")

    def vote(self, tx_hash: str, proof: list, merkle_root: str) -> bool:
        """
        Honest validator s·∫Ω t·ª± x√°c minh Merkle proof:
        - N·∫øu h·ª£p l·ªá th√¨ b·ªè phi·∫øu 'ƒë·ªìng √Ω'
        - N·∫øu kh√¥ng ho·∫∑c validator gian l·∫≠n th√¨ t·ª´ ch·ªëi
        """
        if not self.is_honest:
            return False

        # D√πng MerkleTools ƒë·ªÉ ki·ªÉm tra proof
        is_valid = self.mt.validate_proof(proof, tx_hash, merkle_root)
        return is_valid

```

### server\dc_server.py
```py
import sys, os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify
from blockchains.destination_chain import DestinationChain
from lightclient.light_client_rc import LightClientRC

app = Flask(__name__)
dc = DestinationChain("chainB")

lc_rc = LightClientRC()

@app.route("/receive_ctx", methods=["POST"])
def receive_ctx():
    data = request.json
    result = dc.receive_ctx(
        tx=data["tx"],
        tx_hash_id=data["tx_hash_id"],
        tx_hash=data["tx_hash"],
        merkle_root_rc=data["merkle_root"],
        proof_merkle=data["proof"],
        proof_zk=data["zk_proof"]
    )
    return jsonify({"accepted": result})

@app.route("/get_block", methods=["GET"])
def get_block():
    dc.generate_block()
    return jsonify(dc.get_latest_block())

@app.route("/sync_header", methods=["POST"])
def sync_header():
    header = request.json        # {height, merkle_root, ...}
    ok = lc_rc.update_header(header)
    return jsonify({"updated": ok})

if __name__ == "__main__":
    app.run(port=5003)

```

### server\rc_server.py
```py
import sys, os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify
from relay_chain.relay_chain import RelayChain
from relay_chain.validator import ValidatorNode
from zk_simulator import verify_zk_proof
import requests
from lightclient.light_client_sc import LightClientSC

app = Flask(__name__)
validators = [ValidatorNode(f"v{i}") for i in range(4)]
rc = RelayChain(validators)

# @app.route("/relay_tx", methods=["POST"])
# def relay_tx():
#     data = request.json
#     result = rc.receive_tx(
#         tx=data["tx"],
#         tx_hash=data["tx_hash"],
#         tx_hash_formkl=data["tx_hash_for_mkl"],
#         proof=data["proof"],
#         merkle_root=data["merkle_root"],
#         zk_proof=data["zk_proof"]
#     )
#     return jsonify({"accepted": result})

@app.route("/get_block", methods=["GET"])
def get_block():
    block = rc.generate_block()

    # ƒê·ªìng b·ªô rc LC
    header = {
        "height":      block["height"],
        "merkle_root": block["merkle_root"]
    }

    try:
        rc_res = requests.post("http://localhost:5003/sync_header", json=header, timeout=2).json()
        print("Sync header ‚Üí DC:", rc_res)
    except Exception as e:
        print("‚ö†Ô∏è  Kh√¥ng sync ƒë∆∞·ª£c header sang DC:", e)
    
    return jsonify({
        "tx": block["transactions"],
        "block": block
    })

# rc_server.py
lc_sc = LightClientSC()

@app.route("/sync_header", methods=["POST"])
def sync_header():
    header = request.json        # {height, merkle_root, ...}
    ok = lc_sc.update_header(header)
    return jsonify({"updated": ok})

@app.route("/relay_tx", methods=["POST"])
def relay_tx():
    d = request.json
    # 1. LC ki·ªÉm tra
    ok = lc_sc.verify_tx(
        ctx           = d["tx"],
        merkle_proof  = d["proof"],
        zk_proof      = d["zk_proof"]
    )
    if not ok:
        return jsonify({"accepted": False})

    # 2. chuy·ªÉn qua l·ªõp consensus c·ªßa RC
    accepted = rc.receive_tx(
        tx              = d["tx"],
        tx_hash         = d["tx_hash"],
        tx_hash_formkl  = d["tx_hash_mkl"],
        proof           = d["proof"],
        merkle_root     = lc_sc.merkle_root,
        zk_proof        = d["zk_proof"]
    )
    return jsonify({"accepted": accepted})

@app.route("/get_proof", methods=["POST"])
def get_proof():
    tx = request.json.get("tx")
    proof = rc.get_merkle_proof(tx)
    root = rc.get_merkle_root()
    return jsonify({
        "proof": proof,
        "merkle_root": root
    })


if __name__ == "__main__":
    app.run(port=5002)

```

### server\sc_server.py
```py
import sys, os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify
import requests      
from blockchains.source_chain import SourceChain

app = Flask(__name__)
sc = SourceChain("chainA")

@app.route("/send_tx", methods=["POST"])
def send_tx():
    payload = request.json.get("payload")
    receiver = request.json.get("receiver")
    tx_id = request.json.get("tx_id")

    # T·∫°o transaction v√† sinh block
    tx = sc.add_transaction(payload, receiver, tx_id)
    block = sc.generate_block()

    # Chu·∫©n b·ªã header ƒë·ªÉ sync LC
    header = {
        "height":      block["height"],
        "merkle_root": block["merkle_root"]
    }

    # ƒê·ªìng b·ªô v·ªõi LC
    try:
        rc_res = requests.post("http://localhost:5002/sync_header", json=header, timeout=2).json()
        print("Sync header ‚Üí RC:", rc_res)
    except Exception as e:
        print("‚ö†Ô∏è  Kh√¥ng sync ƒë∆∞·ª£c header sang RC:", e)
    
    return jsonify({
        "tx": tx,
        "block": block
    })

@app.route("/get_proof", methods=["POST"])
def get_proof():
    tx = request.json.get("tx")
    proof = sc.get_merkle_proof(tx)
    root = sc.get_merkle_root()
    return jsonify({
        "proof": proof,
        "merkle_root": root
    })

if __name__ == "__main__":
    app.run(port=5001)

```
